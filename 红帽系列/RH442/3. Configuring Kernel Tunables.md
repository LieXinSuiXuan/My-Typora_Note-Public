[toc]



# Configuring Kernel Tunables（配置内核调优）





## 内核模块调优



### 模块含义：

 在系统中会加载内核，文件系统，网卡驱动等等，这些都是以模块的形式存在于系统中 ，模块是按需加载的，系统中没有正常使用或者是不存在的场景，不会加载对应模块。 

```shell
/lib/modules/4.18.0-80.el8.x86_64/kernel/drivers #模块存放目录
```



某些时候，系统的硬件驱动也是依靠模块来进行加载的，需要去对应的官网上去下载源码包，然后进行安装 

### 网卡模块详解：

在红帽5，网卡名称叫做eth0，网卡的名称是由模块的名称进行了别名

```ini
[root@localhost ~]# vim /etc/modprobe.conf
#模块别名
alias eth0 e1000
alias scsi_hostadapter mptbase
alias scsi_hostadapter1 mptspi
alias scsi_hostadapter2 ata_piix
alias scsi_hostadapter3 ahci
alias snd-card-0 snd-ens1371
#模块调优 
options snd-card-0 index=0 (模块参数)
options snd-ens1371 index=0
remove snd-ens1371 { /usr/sbin/alsactl store 0 >/dev/null 2>&1 || : ; }; /sbin/modprobe -r --ignore-remove snd-ens1371

```

红帽6开始网卡名称的改变引入了udev规则，名称仍然是eth0，但是定义原理发生改变

```shell
[root@localhost ~]# vim  /etc/udev/rules.d/70-persistent-net.rules

# This file was automatically generated by the /lib/udev/write_net_rules
# program, run by the persistent-net-generator.rules rules file.
#
# You can modify it, as long as you keep each rule on a single
# line, and change only the value of the NAME= key.

# PCI device 0x8086:0x100f (e1000) (custom name provided by external tool)
SUBSYSTEM=="net", ACTION=="add", DRIVERS=="?*", ATTR{address}=="00:0c:29:bf:c4:da", ATTR{type}=="1", KERNEL=="eth*", NAME="eth0"

# PCI device 0x8086:0x100f (e1000)
SUBSYSTEM=="net", ACTION=="add", DRIVERS=="?*", ATTR{address}=="00:0c:29:69:94:72", ATTR{type}=="1", KERNEL=="eth*", NAME="eth1"

# PCI device 0x8086:0x100f (e1000)
SUBSYSTEM=="net", ACTION=="add", DRIVERS=="?*", ATTR{address}=="00:0c:29:69:94:7c", ATTR{type}=="1", KERNEL=="eth*", NAME="eth2"
```



### 模块相关命令：

#### 查看模块：

```shell
[root@foundation0 ~]# lsmod
Module                  Size  Used by 
#模块名称               #模块大小 #模块加载的次数 
fuse                  126976  2
rfcomm                 90112  6
rpcsec_gss_krb5        45056  0
vhost_net              24576  7
vhost                  49152  1 vhost_net
tap                    28672  1 vhost_net
ip6t_REJECT            16384  1
```



#### 手动加载模块：

```shell
[root@foundation0 drivers]# modprobe st 
[root@foundation0 drivers]# lsmod  | grep st 
st                     65536  0
```



#### 查看模块详细信息 

```shell
[root@localhost ~]# modinfo  st 
filename:       /lib/modules/2.6.18-164.el5/kernel/drivers/scsi/st.ko            #模块文件名 
alias:          char-major-9-*                                                   #模块别名
license:        GPL
description:    SCSI tape (st) driver
author:         Kai Makisara
srcversion:     33AB9F01F8A25D1F15E5DF2
depends:        scsi_mod
vermagic:       2.6.18-164.el5 SMP mod_unload gcc-4.1
# 模块调优参数
parm:           buffer_kbs:Default driver buffer size for fixed block mode (KB; 32) (int)
parm:           max_sg_segs:Maximum number of scatter/gather segments to use (256) (int)
parm:           try_direct_io:Try direct I/O between user buffer and tape drive (1) (int)
parm:           try_rdio:Try direct read i/o when possible (int)
parm:           try_wdio:Try direct write i/o when possible (int)
module_sig:     883f3504a8b7ca4bd273d74512bb112dc3509cccf1249ad349f8a931933ccb4962d4ddfe52f09f49f76bbd301229c6fb73962ea1f40e220f1e01a
```



### 调整模块参数 （以st模块为例）

```shell
#st模块启动后会在/sys/bus/scsi/drivers 目录中，当卸载掉模块之后，/sys/bus/scsi/drivers 目录中就不存在st模块相关信息
[root@localhost ~]# cd /sys/bus/scsi/drivers 
[root@localhost drivers]# modprobe st 
[root@localhost drivers]# ls
sd  sr  st
[root@localhost drivers]# modprobe -r st 
[root@localhost drivers]# ls 
sd  sr
---------------------------------------------------------------------------------------------------------
#当st模块在启动后，生成st模块相关目录之后，会在目录中产生st模块相关可调优参数，但是不能直接在目录中修改文件内容进行调优，会造成权限拒绝，需要进入/etc/modprobe.d/ 目录中创建相关配置文件，在配置文件中定义
[root@localhost modprobe.d]# cd /etc/modprobe.d/            #进入模块配置目录
[root@localhost modprobe.d]# touch st.conf                  #创建对应模块配置文件
[root@localhost modprobe.d]# cat st.conf                    
options st buffer_kbs=128
[root@localhost modprobe.d]# modprobe -r st                  #卸载模块
[root@localhost modprobe.d]# modprobe st                     #重新启动模块 
[root@localhost modprobe.d]# cat /sys/bus/scsi/drivers/st/fixed_buffer_size  #验证模块参数是否启动成功  
131072
#修改模块参数的时候不要将模块设置为开机启动，将参数写完了之后，重新加载模块的时候自然生成，模块按需加载，不需要设置开机自启 
#当模块对应配置文件中的参数写错了，会使用默认值，红帽8开始不会报错，不会读取错的配置文件 
--至此简单的模块调优成功--
```



### 开机自动加载模块

1.   进入/etc/sysconfig/modules目录中，创建一个以.modules结尾的文件。 
2.   在文件中写入启动模块的命令，每次开机是就会自动加载该目录下的文件 

```shell
[root@localhost ~]# cd /etc/sysconfig/modules/
[root@localhost modules]# touch st.modules 
[root@localhost modules]# cat st.modules  
/usr/bin/modprobe st
```

在开机启动的时候，模块的加载是在很多功能之前来读取的，所以不能只是写开机脚本，需要写在特定的位置才可以，脚本结尾必须是.modules结尾



### 扩展案例

>   附件：[[华科大RAID卡驱动丢失恢复案例.md](./附件2：华科大RAID卡驱动丢失恢复案例.md)]

/lib/modules/2.6.18-164.el5/modules.dep文件中列出了所有的模块的路径。 





## 资源限制：



### limits.conf

具体位置在/etc/security/limits.conf  



#### 控制语法：

```ini
<domain>        <type>  <item>  <value> 
```



#### 控制参数

```ini
#<domain> can be:
#        - a user name
#        - a group name, with @group syntax
#        - the wildcard *, for default entry
#        - the wildcard %, can be also used with %group syntax,
#                 for maxlogin limit
#
#<type> can have the two values:
#        - "soft" 用于强制执行软限制
#        - "hard" 用于强制执行硬限制
#
#<item> can be one of the following:
#        - core - 限制核心文件大小（KB）
#        - data - 最大数据大小（KB）
#        - fsize - 最大文件大小（KB）
#        - memlock - 最大锁定内存地址空间（KB）
#        - nofile - 打开的文件描述符的最大数量
#        - rss - 最大驻留集大小（KB）
#        - stack - 最大堆栈大小（KB）
#        - cpu - 最大CPU时间（MIN）
#        - nproc - 最大进程数
#        - as - address space limit (KB)
#        - maxlogins - max number of logins for this user
#        - maxsyslogins - max number of logins on the system
#        - priority - the priority to run user process with
#        - locks - max number of file locks the user can hold
#        - sigpending - max number of pending signals
#        - msgqueue - max memory used by POSIX message queues (bytes)
#        - nice - max nice priority allowed to raise to values: [-20, 19]
#        - rtprio - max realtime priority
#
#<domain>      <type>  <item>         <value>
#

#*               soft    core            0
#*               hard    rss             10000
#@student        hard    nproc           20
#@faculty        soft    nproc           20
#@faculty        hard    nproc           50
#ftp             hard    nproc           0
#@student        -       maxlogins       4

# End of file
```





## Cgroup

从红帽6开始第一次引入Cgroup 

安装libcgroup包，从而获得cgroup功能

其中docker就是使用Cgroup(资源限制)和namespec(隔离) 

 

### 红帽6

#### Cgroup资源限制

其中/etc/cgconfig.conf文件中指定了cgroup的工作目录 

```shell
[root@localhost ~]# vim /etc/cgconfig.conf 
mount {
        cpuset  = /cgroup/cpuset;
        cpu     = /cgroup/cpu;
        cpuacct = /cgroup/cpuacct;
        memory  = /cgroup/memory;
        devices = /cgroup/devices;
        freezer = /cgroup/freezer;
        net_cls = /cgroup/net_cls;
        blkio   = /cgroup/blkio;
}
```



##### 全局限制

其对资源限制的方法和使用/sys/目录和/proc目录是一样的，通过对Cgroup的工作目录中的调优文件进行修改，来达到资源限制的效果

每个Cgroup中的task文件是资源限制的对象



##### 精准控制

```shell
# 创建资源限制组
vim /etc/cgconfig.conf 
group limit {
  memory {
    memory.limit_in_bytes = 256m;  
    }
}

#引用资源限制组
vim /etc/cgrules.conf 
* memory limit/ 

#重启服务
service cgconfig restart 
```

通过在配置文件中修改组 再在配置文件中指定引用策略人来达到cgroup做资源限制的效果 

红帽6的cgroup资源限制对服务的资源限制没有红帽8强大，主要是针对用户进行资源限制 



### 红帽8 

安装libcgroup之后 会在/sys/fs中生成一个cgroup的工作目录，此工作目录相当于红帽6中的/cgroup工作目录 



